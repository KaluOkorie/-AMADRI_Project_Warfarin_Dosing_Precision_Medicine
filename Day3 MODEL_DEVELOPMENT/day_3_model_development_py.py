# -*- coding: utf-8 -*-
"""DAY 3 MODEL_DEVELOPMENT.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17fj8kTavXVQQI60hNuw2HBlAMFFZxh41

# DAY 3: WARFARIN PRECISION DOSING MODEL DEVELOPMENT
"""

# ============================================================================
# SECTION 1: IMPORTS AND CONFIGURATION
# ============================================================================

import pandas as pd
import numpy as np
from sklearn.linear_model import Ridge
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
import warnings
warnings.filterwarnings('ignore')

# ============================================================================
# SECTION 2: GENETIC ENCODING FUNCTIONS
# ============================================================================

def encode_cyp2c9_function(genotype):
    """Convert CYP2C9 genotype to activity score"""
    activity_map = {
        '*1/*1': 2.0,
        '*1/*2': 1.5,
        '*1/*3': 1.0,
        '*2/*2': 1.0,
        '*2/*3': 0.5,
        '*3/*3': 0.0
    }
    phenotype_map = {
        '*1/*1': 'Normal',
        '*1/*2': 'Intermediate',
        '*1/*3': 'Intermediate',
        '*2/*2': 'Poor',
        '*2/*3': 'Poor',
        '*3/*3': 'Poor'
    }
    activity = activity_map.get(genotype, 1.5)
    phenotype = phenotype_map.get(genotype, 'Intermediate')
    return phenotype, activity

def encode_vkorc1_function(genotype):
    """Convert VKORC1 genotype to sensitivity score"""
    sensitivity_map = {
        'G/G': 0.0,
        'A/G': 1.0,
        'A/A': 2.0
    }
    phenotype_map = {
        'G/G': 'Normal',
        'A/G': 'Intermediate',
        'A/A': 'Sensitive'
    }
    sensitivity = sensitivity_map.get(genotype, 1.0)
    phenotype = phenotype_map.get(genotype, 'Intermediate')
    return phenotype, sensitivity

def encode_cyp4f2_function(genotype):
    """Convert CYP4F2 genotype to score"""
    score_map = {
        'C/C': 0.0,
        'C/T': 1.0,
        'T/T': 2.0
    }
    genotype_type = {
        'C/C': 'Normal',
        'C/T': 'Heterozygous',
        'T/T': 'Variant'
    }
    score = score_map.get(genotype, 0.0)
    genotype_desc = genotype_type.get(genotype, 'Normal')
    return genotype_desc, score

# ============================================================================
# SECTION 3: DATA LOADING CLASS
# ============================================================================

class DataLoader:
    """Loads data from Day 2 outputs"""

    def __init__(self):
        self.X_train_file = 'X_train.csv'
        self.X_val_file = 'X_val.csv'
        self.X_test_file = 'X_test.csv'
        self.y_train_file = 'y_train.csv'
        self.y_val_file = 'y_val.csv'
        self.y_test_file = 'y_test.csv'

    def load(self):
        """Load all datasets"""
        X_train = pd.read_csv(self.X_train_file)
        X_val = pd.read_csv(self.X_val_file)
        X_test = pd.read_csv(self.X_test_file)

        y_train = pd.read_csv(self.y_train_file).squeeze()
        y_val = pd.read_csv(self.y_val_file).squeeze()
        y_test = pd.read_csv(self.y_test_file).squeeze()

        print(f" Loaded: {X_train.shape[0]} training samples")
        print(f" Loaded: {X_val.shape[0]} validation samples")
        print(f" Loaded: {X_test.shape[0]} test samples")

        return X_train, X_val, X_test, y_train, y_val, y_test

# ============================================================================
# SECTION 4: FEATURE ENGINEERING CLASS
# ============================================================================

class FeatureEngineer:
    """Applies genetic and clinical feature engineering"""

    def __init__(self):
        pass

    def engineer(self, df):
        """Apply all feature engineering steps"""
        df = df.copy()

        # Genetic encoding
        df = self._encode_genetic_features(df)

        # Clinical calculations
        df = self._calculate_clinical_features(df)

        # Missing data handling
        df = self._handle_missing_data(df)

        return df

    def _encode_genetic_features(self, df):
        """Encode genetic variants to functional scores"""
        # CYP2C9
        df[['CYP2C9_Phenotype', 'CYP2C9_Activity']] = df['CYP2C9'].apply(
            lambda x: pd.Series(encode_cyp2c9_function(x))
        )

        # VKORC1
        df[['VKORC1_Phenotype', 'VKORC1_Sensitivity']] = df['VKORC1'].apply(
            lambda x: pd.Series(encode_vkorc1_function(x))
        )

        # CYP4F2
        df[['CYP4F2_Genotype', 'CYP4F2_Score']] = df['CYP4F2'].apply(
            lambda x: pd.Series(encode_cyp4f2_function(x))
        )

        # Combined genetic burden
        df['Genetic_Burden'] = (df['CYP2C9_Activity'] + df['VKORC1_Sensitivity']) / 2

        return df

    def _calculate_clinical_features(self, df):
        """Calculate clinical features"""
        # Body Surface Area (BSA)
        if 'Height_cm' in df.columns and 'Weight_kg' in df.columns:
            df['BSA'] = 0.007184 * (df['Height_cm'] ** 0.725) * (df['Weight_kg'] ** 0.425)

        # Estimated GFR (renal function)
        if 'Age' in df.columns and 'Weight_kg' in df.columns and 'Sex' in df.columns:
            sex_factor = np.where(df['Sex'] == 'F', 0.85, 1.0)
            df['eGFR'] = ((140 - df['Age']) * df['Weight_kg'] * sex_factor) / (72 * 1.2)
            df['Renal_Impairment'] = (df['eGFR'] < 60).astype(int)

        # Age categories
        if 'Age' in df.columns:
            df['Elderly'] = (df['Age'] >= 75).astype(int)

        # Obesity
        if 'Height_cm' in df.columns and 'Weight_kg' in df.columns:
            df['BMI'] = df['Weight_kg'] / ((df['Height_cm'] / 100) ** 2)
            df['Obese'] = (df['BMI'] > 30).astype(int)

        return df

    def _handle_missing_data(self, df):
        """Handle missing values"""
        if 'Alcohol_Intake' in df.columns:
            df['Alcohol_Intake'] = df['Alcohol_Intake'].fillna('Unknown')
        return df

# ============================================================================
# SECTION 5: DATA PREPROCESSING CLASS
# ============================================================================

class DataPreprocessor:
    """Handles data scaling and encoding"""

    def __init__(self):
        self.preprocessor = None
        self.feature_names = None

    def fit_transform(self, X_train, X_val, X_test):
        """Fit preprocessor and transform all datasets"""

        # Define feature types
        numerical_features = [
            'Age', 'Weight_kg', 'Height_cm', 'CYP2C9_Activity',
            'VKORC1_Sensitivity', 'CYP4F2_Score', 'Genetic_Burden'
        ]

        categorical_features = [
            'Sex', 'Ethnicity', 'Alcohol_Intake', 'Smoking_Status',
            'Diet_VitK_Intake'
        ]

        # Filter to existing features
        numerical_features = [f for f in numerical_features if f in X_train.columns]
        categorical_features = [f for f in categorical_features if f in X_train.columns]

        print(f"  Numerical features: {len(numerical_features)}")
        print(f"  Categorical features: {len(categorical_features)}")

        # Create and fit preprocessor
        self.preprocessor = ColumnTransformer([
            ('num', StandardScaler(), numerical_features),
            ('cat', OneHotEncoder(drop='first', sparse_output=False), categorical_features)
        ])

        # Transform datasets
        X_train_processed = self.preprocessor.fit_transform(X_train)
        X_val_processed = self.preprocessor.transform(X_val)
        X_test_processed = self.preprocessor.transform(X_test)

        # Get feature names
        self._get_feature_names(numerical_features, categorical_features)

        # Convert to DataFrames
        X_train_df = pd.DataFrame(X_train_processed, columns=self.feature_names)
        X_val_df = pd.DataFrame(X_val_processed, columns=self.feature_names)
        X_test_df = pd.DataFrame(X_test_processed, columns=self.feature_names)

        return X_train_df, X_val_df, X_test_df

    def _get_feature_names(self, numerical_features, categorical_features):
        """Extract feature names from preprocessor"""
        num_feature_names = numerical_features
        cat_encoder = self.preprocessor.named_transformers_['cat']
        cat_feature_names = list(cat_encoder.get_feature_names_out(categorical_features))
        self.feature_names = num_feature_names + cat_feature_names

# ============================================================================
# SECTION 6: MODEL TRAINING CLASS
# ============================================================================

from sklearn.linear_model import Ridge
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from xgboost import XGBRegressor
import pandas as pd
import numpy as np

class ModelTrainer:
    """Trains and evaluates models"""

    def __init__(self, random_state=42):
        self.random_state = random_state
        self.models = {}
        self.results = None

    def train(self, X_train, y_train, X_val, y_val):
        """Train and evaluate all models"""
        # Initialize models
        self.models = {
            'Ridge': Ridge(alpha=1.0, random_state=self.random_state),
            'RandomForest': RandomForestRegressor(
                n_estimators=100,
                max_depth=10,
                random_state=self.random_state,
                n_jobs=-1
            ),
            'XGBoost': XGBRegressor(
                n_estimators=300,
                max_depth=5,
                learning_rate=0.05,
                subsample=0.8,
                colsample_bytree=0.8,
                random_state=self.random_state,
                n_jobs=-1
            )
        }

        # Train and evaluate
        results = []
        for name, model in self.models.items():
            print(f"\n  Training {name}...")

            # Train
            model.fit(X_train, y_train)

            # Predict
            y_train_pred = model.predict(X_train)
            y_val_pred = model.predict(X_val)

            # Calculate metrics
            metrics = self._calculate_metrics(y_train, y_train_pred, y_val, y_val_pred)
            metrics['Model'] = name
            results.append(metrics)

        # Store results
        self.results = pd.DataFrame(results)

        # Display results
        self._display_results()

        # Return best model
        return self._get_best_model()

    def _calculate_metrics(self, y_train, y_train_pred, y_val, y_val_pred):
        """Calculate performance metrics"""
        return {
            'Train_RMSE': np.sqrt(mean_squared_error(y_train, y_train_pred)),
            'Val_RMSE': np.sqrt(mean_squared_error(y_val, y_val_pred)),
            'Train_MAE': mean_absolute_error(y_train, y_train_pred),
            'Val_MAE': mean_absolute_error(y_val, y_val_pred),
            'Train_R2': r2_score(y_train, y_train_pred),
            'Val_R2': r2_score(y_val, y_val_pred)
        }

    def _display_results(self):
        """Display model performance results"""
        print("\n" + "-" * 60)
        print("MODEL PERFORMANCE SUMMARY:")
        print("-" * 60)
        print(self.results.to_string(index=False))

    def _get_best_model(self):
        """Select and return best model"""
        best_model_name = self.results.loc[self.results['Val_RMSE'].idxmin(), 'Model']
        best_model = self.models[best_model_name]
        best_score = self.results['Val_RMSE'].min()

        print(f"\n Best model: {best_model_name} (Val RMSE: {best_score:.4f})")
        return best_model_name, best_model



# ============================================================================
# SECTION 7: IWPC COMPARISON CLASS
# ============================================================================

class IWPCComparator:
    """Compares against IWPC clinical algorithm"""

    def __init__(self):
        pass

    def calculate_iwpc_predictions(self, X):
        """Calculate IWPC algorithm predictions"""
        def iwpc_dose(row):
            base_dose = 5.0

            # Age adjustment
            if row['Age'] < 30:
                base_dose -= 0.5
            elif row['Age'] > 80:
                base_dose += 0.5

            # Weight adjustment
            if row['Weight_kg'] < 60:
                base_dose -= 0.5
            elif row['Weight_kg'] > 100:
                base_dose += 0.5

            # Genetic adjustments
            if 'CYP2C9_Phenotype' in row:
                if row['CYP2C9_Phenotype'] == 'Poor':
                    base_dose *= 0.7
                elif row['CYP2C9_Phenotype'] == 'Intermediate':
                    base_dose *= 0.85

            if 'VKORC1_Phenotype' in row:
                if row['VKORC1_Phenotype'] == 'Sensitive':
                    base_dose *= 0.5
                elif row['VKORC1_Phenotype'] == 'Intermediate':
                    base_dose *= 0.7

            # Drug interaction
            if row['Amiodarone'] == 1:
                base_dose *= 0.7

            return max(1.0, min(10.0, base_dose))

        return X.apply(iwpc_dose, axis=1)

    def compare(self, X_val, y_val, model_rmse):
        """Compare IWPC with model performance"""
        iwpc_preds = self.calculate_iwpc_predictions(X_val)

        iwpc_rmse = np.sqrt(mean_squared_error(y_val, iwpc_preds))
        iwpc_mae = mean_absolute_error(y_val, iwpc_preds)

        print("\n" + "-" * 60)
        print("IWPC CLINICAL ALGORITHM COMPARISON:")
        print("-" * 60)
        print(f"IWPC RMSE: {iwpc_rmse:.4f}")
        print(f"IWPC MAE: {iwpc_mae:.4f}")
        print(f"Model RMSE: {model_rmse:.4f}")
        print(f"Improvement: {(iwpc_rmse - model_rmse):.4f} RMSE")
        print(f"Improvement: {((iwpc_rmse - model_rmse)/iwpc_rmse*100):.1f}%")

# ============================================================================
# SECTION 8: MODEL TESTING CLASS
# ============================================================================

class ModelTester:
    """Tests final model on test set"""

    def __init__(self):
        pass

    def test(self, model, X_test, y_test):
        """Evaluate model on test set"""
        y_pred = model.predict(X_test)

        rmse = np.sqrt(mean_squared_error(y_test, y_pred))
        mae = mean_absolute_error(y_test, y_pred)
        r2 = r2_score(y_test, y_pred)

        print("\n" + "-" * 60)
        print("FINAL MODEL TEST PERFORMANCE:")
        print("-" * 60)
        print(f"Test RMSE: {rmse:.4f}")
        print(f"Test MAE: {mae:.4f}")
        print(f"Test R²: {r2:.4f}")

        # Show sample predictions
        print(f"\nSample predictions (first 5 patients):")
        for i in range(min(5, len(y_test))):
            print(f"  Patient {i+1}: Actual={y_test.iloc[i]:.2f}mg, Predicted={y_pred[i]:.2f}mg")

        return y_pred

# ============================================================================
# SECTION 9: OUTPUT SAVER CLASS
# ============================================================================

class OutputSaver:
    """Saves processed data and models"""

    def __init__(self):
        self.X_train_processed = 'X_train_processed.csv'
        self.X_val_processed = 'X_val_processed.csv'
        self.X_test_processed = 'X_test_processed.csv'
        self.model_file = 'best_model.pkl'
        self.preprocessor_file = 'preprocessor.pkl'

    def save(self, X_train_proc, X_val_proc, X_test_proc, preprocessor, model):
        """Save all outputs"""
        import joblib

        # Save processed datasets
        X_train_proc.to_csv(self.X_train_processed, index=False)
        X_val_proc.to_csv(self.X_val_processed, index=False)
        X_test_proc.to_csv(self.X_test_processed, index=False)

        # Save model and preprocessor
        joblib.dump(model, self.model_file)
        joblib.dump(preprocessor, self.preprocessor_file)

        print("\n" + "-" * 60)
        print("OUTPUT FILES SAVED:")
        print("-" * 60)
        print(f" {self.X_train_processed}")
        print(f" {self.X_val_processed}")
        print(f" {self.X_test_processed}")
        print(f" {self.model_file}")
        print(f" {self.preprocessor_file}")

# ============================================================================
# SECTION 10: MAIN PIPELINE ORCHESTRATOR
# ============================================================================

class WarfarinModelingPipeline:


    def __init__(self):
        # Initialize all components
        self.data_loader = DataLoader()
        self.feature_engineer = FeatureEngineer()
        self.preprocessor = DataPreprocessor()
        self.model_trainer = ModelTrainer()
        self.iwpc_comparator = IWPCComparator()
        self.model_tester = ModelTester()
        self.output_saver = OutputSaver()

        # Results storage
        self.results = {}

    def run(self):
        """Execute complete modeling pipeline"""
        print("=" * 70)
        print("DAY 3: WARFARIN MODELING PIPELINE")
        print("=" * 70)

        # Step 1: Load data
        print("\nSTEP 1: LOADING DATA")
        print("-" * 40)
        X_train, X_val, X_test, y_train, y_val, y_test = self.data_loader.load()

        # Step 2: Feature engineering
        print("\nSTEP 2: FEATURE ENGINEERING")
        print("-" * 40)
        X_train_fe = self.feature_engineer.engineer(X_train)
        X_val_fe = self.feature_engineer.engineer(X_val)
        X_test_fe = self.feature_engineer.engineer(X_test)
        print(f" Engineered features: {X_train_fe.shape[1]} total")

        # Step 3: Data preprocessing
        print("\nSTEP 3: DATA PREPROCESSING")
        print("-" * 40)
        X_train_proc, X_val_proc, X_test_proc = self.preprocessor.fit_transform(
            X_train_fe, X_val_fe, X_test_fe
        )
        print(f" Processed features: {X_train_proc.shape[1]} dimensions")

        # Step 4: Model training
        print("\nSTEP 4: MODEL TRAINING")
        print("-" * 40)
        best_model_name, best_model = self.model_trainer.train(
            X_train_proc, y_train, X_val_proc, y_val
        )

        # Step 5: IWPC comparison
        print("\nSTEP 5: IWPC COMPARISON")
        print("-" * 40)
        best_val_rmse = self.model_trainer.results['Val_RMSE'].min()
        self.iwpc_comparator.compare(X_val_fe, y_val, best_val_rmse)

        # Step 6: Model testing
        print("\nSTEP 6: MODEL TESTING")
        print("-" * 40)
        self.model_tester.test(best_model, X_test_proc, y_test)

        # Step 7: Save outputs
        print("\nSTEP 7: SAVING OUTPUTS")
        print("-" * 40)
        self.output_saver.save(
            X_train_proc, X_val_proc, X_test_proc,
            self.preprocessor.preprocessor, best_model
        )

        print("\n" + "=" * 70)
        print("=" * 70)

# ============================================================================
# SECTION 11: EXECUTION
# ============================================================================

if __name__ == "__main__":
    # Run the complete pipeline
    pipeline = WarfarinModelingPipeline()
    pipeline.run()

    print("\n" + "=" * 70)
    print("NEW FILES CREATED:")
    print("=" * 70)
    print("X_train_processed.csv - Processed training features")
    print("X_val_processed.csv   - Processed validation features")
    print("X_test_processed.csv  - Processed test features")
    print("best_model.pkl        - Trained RandomForest model")
    print("preprocessor.pkl      - Preprocessing pipeline")
    print("=" * 70)

"""The XGBoost model outperformed Ridge and RandomForest with a validation RMSE of 0.6524 mg, achieving an R² of 0.8376. When tested, it maintained strong performance with a test RMSE of 0.6451 mg and R² of 0.8416, representing a 34.7% improvement over the standard IWPC clinical algorithm. The model demonstrates excellent predictive accuracy with dose predictions typically within ±0.65 mg of actual doses—clinically meaningful for warfarin dosing where typical errors exceed 1 mg."""

import shutil
from google.colab import files
import os

# 1. Create a folder to save everything
folder_name = "day2"
if not os.path.exists(folder_name):
    os.makedirs(folder_name)

# 2. Copy all files and directories from the current working directory into this folder
for item in os.listdir():
    if item != folder_name:  # Avoid copying the folder into itself
        shutil.copytree(item, os.path.join(folder_name, item), dirs_exist_ok=True) if os.path.isdir(item) else shutil.copy2(item, folder_name)

# 3. Zip the folder
shutil.make_archive(folder_name, 'zip', folder_name)

# 4. Download the zip
files.download(folder_name + ".zip")